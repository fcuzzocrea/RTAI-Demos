           *** SERVING LINUX SYSCALLS IN RTAI HARD REAL TIMER MODE ***

This example shows an alternative way to be used by hard real RTAI
applications in user space wanting to access Linux services. The other way 
is the RTAI default of moving a task wanting to use Linux back to soft mode,
recovering it to hard real time again at the first RTAI proper service request.

Clearly, in both ways, at the very moment Linux is called the task becomes 
timed by Linux. So hard real time constraints cannot be satisfied anymore.
I do not like any of such solutions very much and prefer an application 
own server that, being specifically taylored, will do it better and with 
full programmer's conscence of what is going on. However users wanting to 
have it simple will be eased a lot, especially during the development phase. 
That's why it's here.

How it works
------------

To use this way a task must call:
rt_linux_syscall_server_create(mytask);
mytask being the task pointer returned by any task/thread init function
available to extend a Linux task to RTAI hard real time. Using NULL for 
mytask is accettable.

Such a call creates a server thread that blocks on a task receive. When the 
RTAI scheduler intercepts a Linux syscall in hard real time mode it rpcs to 
the server thread. The server carries out the syscall and returns its result, 
thus awaking the hard real time task that resumes its execution, remaining 
in hard real time mode always. 

Such an approach clearly shows the power of remote procedure calls as a unified
inter tasks communication and synchronization mechanism. There are clearly two
switches per Linux service request, a standard microkernel way of working.
That, plus the need of copying some data, is responsable for most of the
penalty you have to pay for using this server. The response is not so bad 
anyhow. Moreover recall this is an just an alternative way to what the RTAI 
scheduler will have to do anyhow, i.e. make you soft and recover hard mode at 
the next RTAI proper service call, which will require 4 task switches and keep 
you in Linux hands from the Linux syscall till RTAI is used again. With this 
server you'll stay soft just till Linux has finished servicing your request.

Once more if you want it faster use your own pecific server.

Beware that what explained above makes a few Linux sycalls not executable by
the server (on behalf of the caller).

API Functions prototypes
------------------------

The only function needed is the one reported above, i.e.:
int rt_linux_syscall_server_create(RT_TASK *task);
a zero return meaning success, non zero a failure in setting up the buddy.

Example
-------

It shows the use of a few meaningfull Linux services accessed as explained
above, see the code directly.


Paolo.
